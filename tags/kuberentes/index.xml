<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Open source software for official statistics – kuberentes</title><link>https://glennmdt.github.io/sdmxio/tags/kuberentes/</link><description>Recent content in kuberentes on Open source software for official statistics</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2022 BIS All Rights Reserved</copyright><lastBuildDate>Fri, 06 Aug 2021 10:22:00 +0800</lastBuildDate><atom:link href="https://glennmdt.github.io/sdmxio/tags/kuberentes/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Istio service mesh as API Gateway</title><link>https://glennmdt.github.io/sdmxio/blog/istio-servicemesh-api-gateway/</link><pubDate>Fri, 06 Aug 2021 10:22:00 +0800</pubDate><guid>https://glennmdt.github.io/sdmxio/blog/istio-servicemesh-api-gateway/</guid><description>
&lt;p>API gateways have been around for a long time as the entry point for clients to access the back-end, mainly to manage “north-south” traffic, In recent years, service mesh architectures have become popular, mainly for managing internal systems,(i.e. “east-west” traffic), while a service mesh like Istio also has built-in gateways that bring traffic inside and outside the system under unified control. This often creates confusion for first-time users of Istio. What is the relationship between the service mesh and the API gateway? How does Istio’s gateway work? What are the ways to expose the services in the Istio mesh? This article gives you the answer.&lt;/p>
&lt;h2 id="key-insights">Key Insights&lt;/h2>
&lt;ul>
&lt;li>The service mesh was originally created to solve the problem of managing internal traffic for distributed systems, but API gateways existed long before it.&lt;/li>
&lt;li>While the Gateway is built into Istio, you can still use a custom Ingress Controller to proxy external traffic.&lt;/li>
&lt;li>API gateways and service mesh are converging.&lt;/li>
&lt;/ul>
&lt;h2 id="how-do-i-expose-services-in-the-istio-mesh">How do I expose services in the Istio mesh?&lt;/h2>
&lt;p>The following diagram shows four approaches to expose services in the Istio mesh using Istio Gateway, Kubernetes Ingress, API Gateway, and NodePort/LB.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/istio-servicemesh-api-gateway/access-cluster.svg" data-img="/sdmxio/blog/istio-servicemesh-api-gateway/access-cluster.svg" alt="access-cluster.svg" data-caption="Exposing services through Istio Ingress Gateway">
&lt;figcaption>Exposing services through Istio Ingress Gateway&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>The Istio mesh is shaded, and the traffic in the mesh is internal (east-west) traffic, while the traffic from clients accessing services within the Kubernetes cluster is external (north-south) traffic.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>Approach&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Controller&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Features&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>NodePort/LoadBalancer&lt;/td>
&lt;td>Kubernetes&lt;/td>
&lt;td>Load balancing&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kubernetes Ingress&lt;/td>
&lt;td>Ingress controller&lt;/td>
&lt;td>Load balancing, TLS, virtual host, traffic routing&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Istio Gateway&lt;/td>
&lt;td>Istio&lt;/td>
&lt;td>Load balancing, TLS, virtual host, advanced traffic routing, other advanced Istio features&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>API Gateway&lt;/td>
&lt;td>API Gateway&lt;/td>
&lt;td>Load balancing, TLS, virtual host, advanced traffic routing, API lifecycle management, billing, rate limiting, policy enforcement, data aggregation&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Since NodePort/LoadBalancer is a basic way to expose services built into Kubernetes, this article will not discuss that option. Each of the other three approaches will be described below.&lt;/p>
&lt;h2 id="using-kubernetes-ingress-to-expose-traffic">Using Kubernetes Ingress to expose traffic&lt;/h2>
&lt;p>We all know that clients of a Kubernetes cluster cannot directly access the IP address of a pod because the pod is in a network plane built into Kubernetes. We can expose services inside Kubernetes outside the cluster using NodePort or Load Balancer Kubernetes service type. To support virtual hosting, hiding and saving IP addresses, you can use Ingress resources to expose services in Kubernetes.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/istio-servicemesh-api-gateway/ingress.svg" data-img="/sdmxio/blog/istio-servicemesh-api-gateway/ingress.svg" alt="ingress.svg" data-caption="Kubernetes Ingress to expose services">
&lt;figcaption>Kubernetes Ingress to expose services&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>Ingress is a Kubernetes resource that controls the behavior of an ingress controller that does the traffic touring, which is the equivalent of a load-balanced directional proxy server such as Nginx, Apache, etc., which also includes rule definitions, i.e., routing information for URLs, which is provided by the &lt;a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers" title="Ingress controller" target="_blank" rel="noopener">Ingress controller&lt;/a>
.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">kubernetes.io/ingress.class&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">istio&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpbin.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/status/*&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpbin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">servicePort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8000&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;em>kubernetes.io/ingress.class: istio&lt;/em> annotation in the example above indicates that the Ingress uses the Istio Ingress Controller which in fact uses Envoy proxy.&lt;/p>
&lt;h2 id="using-istio-gateway-to-expose-services">Using Istio Gateway to expose services&lt;/h2>
&lt;p>Istio is a popular service mesh implementation that has evolved from Kubernetes that implements some features that Kubernetes doesn’t. (See &lt;a href="https://www.tetrate.io/blog/what-is-istio-and-why-does-kubernetes-need-it/" title="What is Istio and why does Kubernetes need Istio?" target="_blank" rel="noopener">What is Istio and why does Kubernetes need Istio?&lt;/a>
) It makes traffic management transparent to the application, moving this functionality from the application to the platform layer and becoming a cloud-native infrastructure.&lt;/p>
&lt;p>Istio used Kubernetes Ingress as the traffic portal in versions prior to Istio 0.8, where Envoy was used as the Ingress Controller. From Istio 0.8 and later, Istio created the Gateway object. Gateway and VirtualService are used to represent the configuration model of Istio Ingress, and the default implementation of Istio Ingress uses the same Envoy proxy. In this way, the Istio control plane controls both the ingress gateway and the internal sidecar proxy with a consistent configuration model. These configurations include routing rules, policy enforcement, telemetry, and other service control functions.&lt;/p>
&lt;p>The Istio Gateway resources function similarly to the Kubernetes Ingress in that it is responsible for north-south traffic to and from the cluster. The Istio Gateway acts as a load balancer to carry connections to and from the edge of the service mesh. The specification describes a set of open ports and the protocols used by those ports, as well as the SNI configuration for load balancing, etc.&lt;/p>
&lt;p>The Istio Gateway resource itself can only be configured for L4 through L6, such as exposed ports, TLS settings, etc.; however, the Gateway can be bound to a VirtualService, where routing rules can be configured on L7, such as versioned traffic routing, fault injection, HTTP redirects, HTTP rewrites, and all other routing rules supported within the mesh.&lt;/p>
&lt;p>Below is an example of a Gateway binding to a VirtualService. The pod with the “istio: ingressgateway” label will act as the Ingress controller and route HTTP traffic to port 80 of the httpbin.example.com virtual host. The biggest difference between this and using Kubernetes Ingress is that it requires us to manually bind the VirtualService to the Gateway and specify the pod where the Gateway is located. This configuration is equivalent to opening up an entry point to Kubernetes for external access.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.istio.io/v1alpha3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Gateway&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpbin-gateway&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">istio&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ingressgateway&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">servers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">HTTP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hosts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;httpbin.example.com&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The VirtualService below is bound to the gateway above via &lt;em>gateways&lt;/em> to accept traffic from that gateway.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.istio.io/v1alpha3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">VirtualService&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpbin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hosts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;httpbin.example.com&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">gateways&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">httpbin-gateway&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">match&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uri&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">prefix&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/status&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">route&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">destination&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8000&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">httpbin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="using-an-api-gateway">Using an API Gateway&lt;/h2>
&lt;p>API gateways are API management tools that sit between the client and the back-end service and are widely used in microservices as a way to separate the client interface from the back-end implementation. When a client makes a request, the API gateway breaks it down into multiple requests, then routes them to the correct location, generates a response, and keeps track of everything.&lt;/p>
&lt;p>The API Gateway is a special type of service in the microservices architecture that serves as the entry point for all microservices and is responsible for performing routing requests, protocol conversions, aggregating data, authentication, rate limiting, circuit breaking, and more. Most enterprise APIs are deployed through API Gateways, which typically handle common tasks across API service systems, such as TLS termination, authentication and authorization, rate limiting, and statistical information.&lt;/p>
&lt;p>There can be one or more API Gateways in the mesh. The responsibilities of the API Gateway are&lt;/p>
&lt;ul>
&lt;li>Request routing and version control&lt;/li>
&lt;li>Facilitating the transition of monolithic applications to microservices&lt;/li>
&lt;li>Permission authentication&lt;/li>
&lt;li>Data aggregation: monitoring and billing&lt;/li>
&lt;li>Protocol conversion&lt;/li>
&lt;li>Messaging and caching&lt;/li>
&lt;li>Security and alerting&lt;/li>
&lt;/ul>
&lt;p>Many of the above basic functions such as routing and permission authentication can also be achieved through Istio Gateway, but some mature API gateways may be more advantageous in terms of feature richness and scalability.&lt;/p>
&lt;ul>
&lt;li>The introduction of API Gateway requires consideration of the deployment, operation and maintenance, load balancing, and other scenarios of API Gateway itself, which increases the complexity of back-end services.&lt;/li>
&lt;li>An API Gateway carries a large number of interface adaptations, which makes it difficult to maintain.&lt;/li>
&lt;li>For some scenarios, the addition of a hop may lead to a reduction in performance.&lt;/li>
&lt;/ul>
&lt;p>Currently, some API Gateway imitations are building their own service mesh by deploying them in the sidecar.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>In the Istio mesh, you can use a variety of Kubernetes Ingress Controllers to act as entry gateways, but of course, you can also use Istio’s built-in Istio Gateway directly, for policy control, traffic management, and usage monitoring. The advantage of this is that the gateway can be managed directly through Istio’s control plane, without the need for additional tools. But for functions such as API statement cycle management, complex billing, protocol conversion, and authentication, a traditional API gateway may be a better fit for you. So, you can choose according to your needs, or you can use a combination.&lt;/p>
&lt;p>Some traditional reverse proxies are also moving towards Service Mesh, such as Nginx with Nginx Service Mesh and Traefik with Traefik Mesh, and some API gateway products are also moving towards Service Mesh, such as Kong with Kuma, and in the future, we will see more convergence of API gateways, reverse proxies, and service meshes.&lt;/p></description></item><item><title>Multicluster Management with Kubernetes and Istio</title><link>https://glennmdt.github.io/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/</link><pubDate>Mon, 12 Jul 2021 22:22:00 +0800</pubDate><guid>https://glennmdt.github.io/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/</guid><description>
&lt;p>Do you have multiple Kubernetes clusters and a service mesh? Do your virtual machines and services in a Kubernetes cluster need to interact? This article will take you through the process and considerations of building a hybrid cloud using Kubernetes and an Istio Service Mesh. Together, Kubernetes and Istio can be used to bring hybrid workloads into a mesh and achieve interoperability for multicluster. But another layer of infrastructure — a management plane — is helpful for managing multicluster or multimesh deployments.&lt;/p>
&lt;h2 id="kubernetes">Kubernetes&lt;/h2>
&lt;p>Using Kubernetes enables rapid deployment of a distributed environment that enables cloud interoperability and unifies the control plane on the cloud. It also provides resource objects, such as Service, Ingress and &lt;a href="https://kubernetes.io/blog/2021/04/22/evolving-kubernetes-networking-with-the-gateway-api/" title="Gateway" target="_blank" rel="noopener">Gateway&lt;/a>
, to handle application traffic. The Kubernetes API Server communicates with the kube-proxy component on each node in the cluster, creates iptables rules for the node, and forwards requests to other pods.&lt;/p>
&lt;p>Assuming that a client now wants to access a service in Kubernetes, the request is first sent to the Ingress/Gateway, then forwarded to the backend service (Service A in the diagram below) based on the routing configuration in the Ingress/Gateway. Then Service A polls an instance of Service B for the traffic requested by Service B. Lastly, the traffic requested by Service A for Service B is polled forward to Service B’s instance.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6a11l1j31lu0u042s.jpg" data-img="/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6a11l1j31lu0u042s.jpg" data-width="2082" data-height="1080" alt="008i3skNly1gsgg6a11l1j31lu0u042s.jpg" data-caption="Kubernetes">
&lt;figcaption>Kubernetes&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="kubernetes-multicluster">Kubernetes Multicluster&lt;/h2>
&lt;p>The most common usage scenarios for multicluster management include:&lt;/p>
&lt;ul>
&lt;li>service traffic load balancing&lt;/li>
&lt;li>isolating development and production environments&lt;/li>
&lt;li>decoupling data processing and data storage&lt;/li>
&lt;li>cross-cloud backup and disaster recovery&lt;/li>
&lt;li>flexible allocation of compute resources&lt;/li>
&lt;li>low-latency access to services across regions&lt;/li>
&lt;li>avoiding vendor lock-in&lt;/li>
&lt;/ul>
&lt;p>There are often multiple Kubernetes clusters within an enterprise; and the &lt;a href="https://github.com/kubernetes-sigs/kubefed" title="KubeFed" target="_blank" rel="noopener">KubeFed&lt;/a>
implementation of Kubernetes cluster federation developed by &lt;a href="https://github.com/kubernetes/community/blob/master/sig-multicluster/README.md" title="Multicluster SIG" target="_blank" rel="noopener">Multicluster SIG&lt;/a>
enables multicluster management capabilities, which allows all Kubernetes clusters to be managed through the same interface.&lt;/p>
&lt;p>There are several general issues that need to be addressed when using cluster federation:&lt;/p>
&lt;ul>
&lt;li>Configuring which clusters need to be federated&lt;/li>
&lt;li>API resources need to be propagated across the clusters&lt;/li>
&lt;li>Configuring how API resources are distributed to different clusters&lt;/li>
&lt;li>Registering DNS records in clusters to enable service discovery across clusters&lt;/li>
&lt;/ul>
&lt;p>The following is a multicluster architecture for &lt;a href="https://kubesphere.io/" title="KubeSphere" target="_blank" rel="noopener">KubeSphere&lt;/a>
— one of the most commonly used Kubernetes multicluster management architectures — where the Host Cluster serves as the control plane with two member clusters, West and East.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg7a2ojvj31aa0u0491.jpg" data-img="/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg7a2ojvj31aa0u0491.jpg" data-width="1666" data-height="1080" alt="008i3skNly1gsgg7a2ojvj31aa0u0491.jpg" data-caption="Multicluster">
&lt;figcaption>Multicluster&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>The Host Cluster needs to be able to access the API Server of the Member Cluster, but the network connectivity between Member Clusters is not required. The Host Cluster is independent of the Member Cluster it manages and the Member Cluster is not aware of the existence of the Host Cluster. The advantage of this is that when the control plane fails, the Member Cluster will not be affected and the deployed load can still operate normally without being affected.&lt;/p>
&lt;p>The Host Cluster also assumes the role of API portal, and the Host Cluster forwards the resource requests to the Member Cluster — which is convenient for aggregation and also facilitates unified authority authentication. We see that there is a Federation Control Plane in the Host Cluster, where the Push Reconciler propagates the identity, role, and role binding from the Federation Cluster to all Member Clusters.&lt;/p>
&lt;h2 id="istio-service-mesh">Istio Service Mesh&lt;/h2>
&lt;p>Consider using the Istio service mesh when we have multilingual, multiversion microservices running in Kubernetes and need finer-grained canary publishing and unified security policy management for inter-service observability. Istio enables intelligent application-aware load balancing from the application layer to other Service Mesh-enabled services in the cluster, by transparently intercepting all traffic to and from the application using IPTables, and bypassing the primary kube-proxy load balancing. The Istio control plane communicates with the Kubernetes API Server to obtain information about all registered services in the cluster.&lt;/p>
&lt;p>The following diagram illustrates the basics of Istio, where all nodes belong to the same Kubernetes cluster.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg" data-img="/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg" data-width="3714" data-height="1080" alt="008i3skNly1gsgg6sdrk2j32v60u0qbb.jpg" data-caption="Istio Service Mesh">
&lt;figcaption>Istio Service Mesh&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>You may end up with at least a few Kubernetes clusters, each hosting microservices. Multiple &lt;a href="https://istio.io/latest/docs/setup/install/multicluster/" title="deployment models" target="_blank" rel="noopener">deployment models&lt;/a>
exist for Istio’s multicluster deployments — depending on network isolation, primary and backup — which can be specified by declaration when deploying using Istio Operator. Communication between these microservices in a cluster can be enhanced by a service mesh. Within the cluster, Istio provides common communication patterns to improve resiliency, security and observability.&lt;/p>
&lt;p>All of the above is about application load management on Kubernetes, but for legacy applications on virtual machines: how can they be managed in the same plane? Istio supports applications on virtual machines, so why do we need a management plane?&lt;/p>
&lt;h2 id="management-plane">Management Plane&lt;/h2>
&lt;p>To manage gateways, traffic and security groupings, and apply them to different clusters and namespaces, you’ll need to add another layer of abstraction on top of Istio: a management plane. The diagram below shows the multitenant model of Tetrate Service Bridge (TSB). TSB uses Next Generation Access Control (NGAC) — a fine-grained authorization framework — to manage user access and also facilitate the construction of a zero-trust network.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg8ndcajj31il0u00z9.jpg" data-img="/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg8ndcajj31il0u00z9.jpg" data-width="1965" data-height="1080" alt="008i3skNly1gsgg8ndcajj31il0u00z9.jpg" data-caption="Management Plane">
&lt;figcaption>Management Plane&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>Istio provides workload identification, protected by strong mTLS encryption. This zero-trust model is better than trusting workloads based on topology information, such as source IP. A common control plane for multicluster management is built on top of Istio. Then a management plane is added to manage multiple clusters — providing multitenancy, management configuration, observability, and more.&lt;/p>
&lt;p>The diagram below shows the architecture of Tetrate Service Bridge.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg951mknj314g0u0dnf.jpg" data-img="/sdmxio/blog/multicluster-management-with-kubernetes-and-istio/008i3skNly1gsgg951mknj314g0u0dnf.jpg" data-width="1456" data-height="1080" alt="008i3skNly1gsgg951mknj314g0u0dnf.jpg" data-caption="Tetrate Service Bridge">
&lt;figcaption>Tetrate Service Bridge&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>Interoperability of heterogeneous clusters is achieved with Kubernetes. Istio brings containerized and virtual machine loads into a single control plane, to unify traffic, security and observability within the clusters. However, as the number of clusters, network environments and user permissions become more complex, there is a need to build another management plane above Istio’s control plane (for example, &lt;a href="https://www.tetrate.io/tetrate-service-bridge/" title="Tetrate Service Bridge" target="_blank" rel="noopener">Tetrate Service Bridge&lt;/a>
) for hybrid cloud management.&lt;/p></description></item></channel></rss>