<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Open source software for official statistics – istio</title><link>https://glennmdt.github.io/sdmxio/tags/istio/</link><description>Recent content in istio on Open source software for official statistics</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2022 BIS All Rights Reserved</copyright><lastBuildDate>Sun, 15 May 2022 14:18:40 +0800</lastBuildDate><atom:link href="https://glennmdt.github.io/sdmxio/tags/istio/index.xml" rel="self" type="application/rss+xml"/><item><title>How to build Istio?</title><link>https://glennmdt.github.io/sdmxio/blog/how-to-build-istio/</link><pubDate>Sun, 15 May 2022 14:18:40 +0800</pubDate><guid>https://glennmdt.github.io/sdmxio/blog/how-to-build-istio/</guid><description>
&lt;p>This article will guide you on how to compile the Istio binaries and Docker images on macOS.&lt;/p>
&lt;h2 id="before-you-begin">Before you begin&lt;/h2>
&lt;p>Before we start, refer to the &lt;a href="https://github.com/istio/istio/wiki/Preparing-for-Development-Mac" title="Istio Wiki" target="_blank" rel="noopener">Istio Wiki&lt;/a>
, here is the information about my build environment.&lt;/p>
&lt;ul>
&lt;li>macOS 12.3.1 Darwin AMD64&lt;/li>
&lt;li>Docker Desktop 4.8.1(78998)&lt;/li>
&lt;li>Docker Engine v20.10.14&lt;/li>
&lt;/ul>
&lt;h2 id="start-to-compile">Start to compile&lt;/h2>
&lt;p>First, download the &lt;a href="https://github.com/istio/istio" title="Istio code" target="_blank" rel="noopener">Istio code&lt;/a>
from GitHub to the &lt;code>$GOPATH/src/istio.io/istio&lt;/code> directory, and execute the commands below in that root directory.&lt;/p>
&lt;h3 id="compile-into-binaries">Compile into binaries&lt;/h3>
&lt;p>Execute the following command to download the Istio dependent packages, which will be downloaded to the &lt;code>vendor&lt;/code> directory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">go mod vendor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Run the following command to build Istio:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo make build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you do not run the command with &lt;code>sudo&lt;/code>, you may encounter the following error.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">fatal: unsafe repository &lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;/work&amp;#39;&lt;/span> is owned by someone &lt;span class="k">else&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">To add an exception &lt;span class="k">for&lt;/span> this directory, call:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> git config --global --add safe.directory /work
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fatal: unsafe repository &lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;/work&amp;#39;&lt;/span> is owned by someone &lt;span class="k">else&lt;/span>&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">To add an exception &lt;span class="k">for&lt;/span> this directory, call:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> git config --global --add safe.directory /work
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Makefile.core.mk:170: *** &lt;span class="s2">&amp;#34;TAG cannot be empty&amp;#34;&lt;/span>. Stop.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make: *** &lt;span class="o">[&lt;/span>build&lt;span class="o">]&lt;/span> Error &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Even if you follow the prompts and run &lt;code>git config --global --add safe.directory /work&lt;/code>, you will still get errors during compilation.&lt;/p>
&lt;p>The compiled binary will be saved in &lt;code>out&lt;/code> directory with the following directory structure.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">out
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── darwin_amd64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── bug-report
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── client
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── envoy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── extauthz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── install-cni
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── istio-cni
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── istio-cni-taint
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── istio-iptables
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── istio_is_init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── istioctl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── logs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── operator
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── pilot-agent
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── pilot-discovery
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ ├── release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│ └── server
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── linux_amd64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── envoy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── envoy-centos
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── logs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── release
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It will build both the &lt;code>linux_amd64&lt;/code> and &lt;code>darwin_amd64&lt;/code> architectures binaries at the same time.&lt;/p>
&lt;h3 id="compile-into-docker-images">Compile into Docker images&lt;/h3>
&lt;p>Run the following command to compile Istio into a Docker image.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo make build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The compilation will take about 3 to 5 minutes depending on your network. Once the compilation is complete, you will see the Docker image of Istio by running the following command.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ docker images
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/app_sidecar_centos_7 latest 2044037df94b &lt;span class="m">51&lt;/span> seconds ago 524MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/app_sidecar_ubuntu_jammy latest 5d8ae5ed55b7 About a minute ago 362MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/proxyv2 latest d4679412385f About a minute ago 243MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/install-cni latest 78f46d5771d2 About a minute ago 270MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/istioctl latest c38130a5adc8 About a minute ago 190MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/pilot latest 2aa9185ec202 About a minute ago 190MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/app latest 473adafaeb8d About a minute ago 188MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/operator latest 9ac1fedcdd12 About a minute ago 191MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/ext-authz latest 1fb5aaf20791 About a minute ago 117MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/app_sidecar_debian_11 latest 61376a02b95d &lt;span class="m">2&lt;/span> minutes ago 407MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">localhost:5000/app_sidecar_ubuntu_xenial latest 7e8efe666611 &lt;span class="m">2&lt;/span> minutes ago 418MB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can change the image name and push it into your own container registry.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>This is how to build Istio on macOS. If you have already downloaded the Docker image you need to build, the build will take less than a minute. It also takes only a few minutes to build Docker images.&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/istio/istio/wiki/Using-the-Code-Base" title="Using the Code Base - github.com" target="_blank" rel="noopener">Using the Code Base - github.com&lt;/a>
&lt;/li>
&lt;/ul></description></item><item><title>How to debug microservices in Kubernetes with proxy, sidecar or service mesh?</title><link>https://glennmdt.github.io/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/</link><pubDate>Mon, 05 Jul 2021 22:22:00 +0800</pubDate><guid>https://glennmdt.github.io/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/</guid><description>
&lt;p>Kubernetes is arguably the best environment for running microservices so far, but the experience of debugging microservices in a Kubernetes environment may not be as user-friendly. This article will show you how to debug microservices in Kubernetes, introduce common tools, and explain how the introduction of Istio impacts debugging microservices.&lt;/p>
&lt;h2 id="debugging-microservices-is-vastly-different-from-traditional-monolithic-applications">Debugging microservices is vastly different from traditional monolithic applications&lt;/h2>
&lt;p>The debugging of microservices has been a long-standing problem for software developers. This challenge does not exist in traditional monolithic applications because developers can leverage the debugger in IDEs to add breakpoints, modify environment variables, single-step execution, etc. for their applications, all of which provide great help in software debugging. With the popularity of Kubernetes, the debugging of microservices becomes a thorny issue, where the following issues are more complicated than the debugging of traditional monolithic applications.&lt;/p>
&lt;h3 id="multiple-dependencies">Multiple dependencies&lt;/h3>
&lt;p>A microservice often depends on multiple other microservices, some shared volumes across multiple microservices, and authorizations based on service accounts. When debugging a microservice, how do you deploy other dependent services to quickly build a latest set of staging environments?&lt;/p>
&lt;h3 id="access-from-a-local-machine">Access from a local machine&lt;/h3>
&lt;p>When microservices are running on a developer’s local computer, there is usually no direct access to the services in a Kubernetes cluster. How can you debug microservices deployed in a Kubernetes cluster as if they were local services?&lt;/p>
&lt;h3 id="slow-development-loop">Slow development loop&lt;/h3>
&lt;p>Usually, it takes a long process to update the code and build it into an image before pushing it to the cluster. How do you speed up the development cycle? Let’s look at the tools that address those challenges.&lt;/p>
&lt;h2 id="tools">Tools&lt;/h2>
&lt;p>The main solutions for debugging microservices in Kubernetes are:&lt;/p>
&lt;ul>
&lt;li>Proxy: by building a VPN, deploying a proxy in the Kubernetes cluster, and adding local debug endpoints to make the services in Kubernetes directly accessible to local applications, your architecture will look like [ local service ] &amp;lt;-&amp;gt; [ proxy ] &amp;lt;-&amp;gt; [ app in Kubernetes ].&lt;/li>
&lt;li>Sidecar: Inject a sidecar into the pod of the microservice to be debugged to intercept all traffic to and from the service, so that the service can be tracked and monitored, and the service can also be debugged in this sidecar.&lt;/li>
&lt;li>Service Mesh: To get an overall picture of the application, inject sidecars into all microservices so that you can get a dashboard that monitors global status.&lt;/li>
&lt;/ul>
&lt;p>Here are three typical open source projects that implement the above solutions, each of which can help you debug microservices from a different perspective. You can apply them at different stages of software development and they can be said to be complementary to each other.&lt;/p>
&lt;h3 id="proxy--debugging-microservices-with-telepresence">Proxy – debugging microservices with Telepresence&lt;/h3>
&lt;p>&lt;a href="https://www.telepresence.io/" title="Telepresence" target="_blank" rel="noopener">Telepresence&lt;/a>
is essentially a local proxy that proxies data volumes, environment variables, and networks in a Kubernetes cluster locally. The following diagram shows the main usage scenarios for Telepresence.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/telepresence.jpg" data-img="/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/telepresence.jpg" data-width="1080" data-height="1197" alt="telepresence.jpg" data-caption="Proxy mode: Telepresence">
&lt;figcaption>Proxy mode: Telepresence&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>Users need to manually execute the telepresence command locally, which will automatically deploy the agent to Kubernetes. Once the agent has been deployed,&lt;/p>
&lt;ul>
&lt;li>Local services will have complete access to other services in the Kubernetes cluster, environment variables, Secret, ConfigMap, etc.&lt;/li>
&lt;li>Services in the cluster also have direct access to the locally exposed endpoints.&lt;/li>
&lt;/ul>
&lt;p>However, this approach requires users to run multiple commands while debugging locally, and in some network environments it may not be possible to establish a VPN connection to the Kubernetes cluster.&lt;/p>
&lt;h3 id="sidecar--debugging-microservices-with-nocalhost">Sidecar – debugging microservices with Nocalhost&lt;/h3>
&lt;p>&lt;a href="https://nocalhost.dev/" title="Nocalhost" target="_blank" rel="noopener">Nocalhost&lt;/a>
is a Kubernetes-based cloud development environment. To use it, you just need to install a plugin in your IDE – VS Code to extend Kubernetes and shorten the development feedback cycle. The development environment can be isolated by creating different namespaces for different users and using ServiceAccount when binding to different user corners. Nocalhost also provides a web console and API for administrators to manage different development environments.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/sidecar-nocalhost.jpg" data-img="/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/sidecar-nocalhost.jpg" data-width="1928" data-height="1080" alt="sidecar-nocalhost.jpg" data-caption="Sidecar mode: Nocalhost">
&lt;figcaption>Sidecar mode: Nocalhost&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>As long as you have a Kubernetes cluster and have admin rights to the cluster, you can refer to the &lt;a href="https://nocalhost.dev/getting-started/" title="Nocalhost documentation" target="_blank" rel="noopener">Nocalhost documentation&lt;/a>
to quickly start trying it out. To use the Nocalhost plugin in VS Code, you need to configure the Kubernetes cluster in the plugin first.&lt;/p>
&lt;ol>
&lt;li>Select the Kubeconfig file you just exported or copy and paste the contents of the file directly into the configuration.&lt;/li>
&lt;li>Then select the service you need to test and select the corresponding Dev Container. VS Code will automatically open a new code window.&lt;/li>
&lt;/ol>
&lt;p>Here is an example of the &lt;a href="https://istio.io/latest/docs/examples/bookinfo/" title="bookinfo sample" target="_blank" rel="noopener">bookinfo sample&lt;/a>
provided by Istio. You can open the cloned code in your local IDE and click the hammer next to the code file to enter development mode. Selecting the corresponding DevContainer and Nocalhost will automatically inject a development container sidecar into the pod and automatically enter the container in the terminal, as shown in the following figure.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-vs-code.jpg" data-img="/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-vs-code.jpg" data-width="1722" data-height="1080" alt="nocalhost-vs-code.jpg" data-caption="Nocalhost VS code">
&lt;figcaption>Nocalhost VS code&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>In development mode, the code is modified locally without rebuilding the image, and the remote development environment takes effect in real time, which can greatly accelerate the development speed. At the same time, Nocalhost also provides a server for managing the development environment and user rights, as shown in the following figure.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-web-admin.jpg" data-img="/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/nocalhost-web-admin.jpg" data-width="2354" data-height="1080" alt="nocalhost-web-admin.jpg" data-caption="Nocalhost Web">
&lt;figcaption>Nocalhost Web&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="service-mesh--debugging-microservices-with-istio">Service Mesh – debugging microservices with Istio&lt;/h3>
&lt;p>The above method of using proxy and sidecar can only debug one service at a time. You’ll need a mesh to get the global status of the application, such as the metrics of the service obtained, and debug the performance of the service by understanding the dependency and invocation process of the service through distributed tracing. These observability features need to be implemented by injecting sidecar uniformly for all services. And, when your services are in the process of migrating from VMs to Kubernetes, using Istio can bring VMs and Kubernetes into a single network plane (as shown below), making it easy for developers to debug and do incremental migrations.&lt;/p>
&lt;p>&lt;figure class="mx-auto text-center">
&lt;img src="https://glennmdt.github.io/sdmxio/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/istio-service-mesh.jpg" data-img="/sdmxio/blog/how-to-debug-microservices-in-kubernetes-with-proxy-sidecar-or-service-mesh/istio-service-mesh.jpg" data-width="1956" data-height="1080" alt="istio-service-mesh.jpg" data-caption="Serivce Mesh mode: Istio">
&lt;figcaption>Serivce Mesh mode: Istio&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>Of course, these benefits do not come without a “cost.” With the introduction of Istio, your Kubernetes services will need to adhere to the Istio naming convention and you’ll need to know how to debug microservices using the Istioctl command line and logging.&lt;/p>
&lt;ul>
&lt;li>Use the &lt;em>istioctl analyze&lt;/em> command to debug the deployment of microservices in your cluster, and you can use YAML files to examine the deployment of resources in a namespace or across your cluster.&lt;/li>
&lt;li>Use &lt;em>istioctl proxy-config secret&lt;/em> to ensure that the secret of a pod in a service mesh is loaded correctly and is valid.&lt;/li>
&lt;/ul>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>In the process of microservicing applications and migrating from virtual machines to Kubernetes, developers need to make a lot of changes in their mindset and habits. By building a VPN between local and Kubernetes via proxy, developers can easily debug services in Kubernetes as if they were local services. By injecting a sidecar into the pod, you can achieve real-time debugging and speed up the development process. Finally, the Istio service mesh truly enables global observability, and you can also use tools like &lt;a href="https://www.tetrate.io/tetrate-service-bridge/" title="Tetrate Service Bridge" target="_blank" rel="noopener">Tetrate Service Bridge&lt;/a>
to manage heterogeneous platforms, helping you gradually move from monolithic applications to microservices.&lt;/p></description></item></channel></rss>